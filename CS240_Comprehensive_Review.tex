\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algpseudocode}
\usepackage{soul}
\usepackage{bookman}

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\title{CS240 Comprehensive Review}
\author{Theo Park}
\date{3 May 2022}

\begin{document}

\maketitle

\section{Basics}
\st{C was developed by our lord Turkstra in 1678.}\\
Created by Dennis Ritchie in 1969 (nice) - 1973 at Bell Lab, with a desire to make UNIX portable unlike assembly.
It's portable, fast, and simple, so screw you Javascript.


\section{Compiling and Linking}

\subsection{Gcc Flags}
\begin{itemize}
    \item \textit{-c} Compile file into object file
    \item \textit{-g} Debugging symbols
    \item \textbf{\textit{-Wall}} Include ALL Warning
    \item \textbf{\textit{-Werror}} Turn wanings into errors
    \item \textbf{\textit{-O1, -O2, -O3}} Optimize output code
    \item \textbf{\textit{-o filename}} Output to filename
    \item \textit{-ANSI} Adhere to ANSI std
    \item \textit{-std=C99} Adhere to C99 std
\end{itemize}

\subsection{Linking}
Object file contains binary code, symbol tables, and is a compiled form of a C module.
To make it a complete executable, one must link object files, with one of them containing main().

\section{File I/O}

\subsection{Essentials}
\begin{itemize}
    \item FILE *fopen(char *file\_name, char *mode);\\
    Modes are "r", "w", and "a" (append). Returns file ptr on success, NULL on unsuccess, so one must check the return val of fopen().
    \item int fclose(FILE *file\_pointer);\\
    It does not set the file ptr to NULL, so you have to manually set it to NULL. Return val check isn't necessary in this class.
    \item \textbf{int fprinf(FILE *stream, const char *format, \dots);}
    \item \textbf{int fscanf(FILE *stream, const char *format, \dots);}
    \item int access(char *file\_name, int mode);\\
    Used to check if file can be accessed in "R\_OK", "W\_OK", or "F\_OK" (check for existence) mode.
    \item int feof(FILE *file\_pointer);\\
    Returns non-zero if EOF reached.
    \item int ferror(FILE *file\_pointer);\\
    Returns 0 if error occurs (e.g disk space full).
\end{itemize}

\subsection{Notes with fscanf()}
\begin{itemize}
    \item Utilize \%[] (\%[0-9A-z] \%[\^{}A-z])
    \item \textbf{Field width specifier (e.g \%49s \%49[A-z]). Always one less than the buffer size to account for NUL terminator.}
    \item Assigns variables to pointers; use \& symbol for non-strings.
    \item Returns number of successfully read variables; Check for error using the return value.
\end{itemize}

\subsection{Random Access File I/O}
\begin{itemize}
    \item \textbf{int ftell(FILE *file\_pointer);}\\
    Returns current offset from the beginning of the file (SEEK\_SET) or -1 in case of error.
    \item \textbf{int fseek(FILE *fp, long int offset, int whence);}\\
    Whence values include
    \begin{itemize}
        \item SEEK\_SET: Offset relative to beginning of the file 
        \item SEEK\_CUR: Offset relative to the current position
        \item SEEK\_END: Offset relative to the end of the file
    \end{itemize}
    \item Example of finding how long the file is:
    \begin{algorithmic}
        \item fseek(fp, 0, SEEK\_END);
        \item int len = ftell(fp);
        \item fseek(fp, 0, SEEK\_SET);
    \end{algorithmic}
\end{itemize}

\section{Struct and Typedef}

\subsection{Some Syntax}
\begin{itemize}
    \item Typedef and struct definition:
    \begin{algorithmic}
        \item typedef struct my\_data \{\\
            $\indent$ int age;\\
        \} my\_data\_t;
    \end{algorithmic}
    \item Struct definition and declaration:
    \begin{algorithmic}
        \item struct my\_data \{\\
            $\indent$ int age;\\
        \} my\_var = \{ 19 \};
    \end{algorithmic}
\end{itemize}

\subsection{Declaration vs Definition}
Declaration is announcing the properties of var (no memory allocation), definition is allocating storages for a var.
\begin{itemize}
    \item Declaration:
    \begin{algorithmic}
        \item struct my\_data \{\\
            $\indent$ int age;\\
        \};
    \end{algorithmic}
    \item Definition and initialization:
    \begin{algorithmic}
        \item struct my\_data my\_var = \{ 19 \};
    \end{algorithmic}
\end{itemize}
Put pure declaration (struct, func prototype, extern) outside of the func, put definition inside func.

\subsection{Initializing/Assigning Elements in Struct}
\begin{algorithmic}
        \item struct my\_data = \{\\
        $\indent$ int age;\\
        $\indent$ int random\_stuffs[2];\\
    \};\\
\end{algorithmic}
When initializing, just to it normally.
\begin{algorithmic}
    \item struct my\_data my\_var = \{ 12, \{ 3, 4 \} \}
\end{algorithmic}
Usually, assigning elements are done individually
\begin{algorithmic}
    \item struct my\_data my\_var = \{ 122 , \{ 33 , 44 \} \}; /* Oh no mistakes */\\
    my\_var.age = 12;\\
    my\_var.random\_stuffs[0] = 3;\\
    my\_var.random\_stuffs[1] = 4;
\end{algorithmic}
In C99, you can do it all at once with compound literal.
\begin{algorithmic}
    \item my\_var = (struct my\_data) \{ 12, \{ 3, 4 \} \}
\end{algorithmic}

\section{Memory}

\subsection{Array and String}
\begin{itemize}
    \item When a global array is initialized, or a local array is partially initialized, any non-initialized elements are 0.
    \item \textbf{Use strncpy(str1, str2, num), with last arg being sizeof(str1)} (in stack allocated memory settings).
    \item strcmp(str1, str2) returns 0 if they are the same, positive number if str2 comes before str1, negative if str1 comes before str2.
\end{itemize}

\subsection{Memory Map}
Take the L

\subsection{Padding}
Structure is padded in C when smaller size variable is followed by bigger size variable. 
Padding of sizeof(bigger\_var) - sizeof(smaller\_var) will be added in between for a faster access.
\begin{algorithmic}
    \item struct example \{\\
        $\indent$ char a; /* 1 bytes */\\
        $\indent$ char b; /* 1 bytes */\\
        $\indent$ int c; /* 4 bytes */\\
        $\indent$ /* Prev. element adding up to 6, thus 2 bytes of padding */\\
        $\indent$ struct example *next /* 8 bytes */\\
    \};
\end{algorithmic}
Size of struct example is 16 bytes (in 64 bit system). Remember that the size of structure should be a multiple of the biggest variable.

\subsection{Binary File I/O}
\begin{itemize}
    \item \textbf{int fwrite(void *ptr, int size, int num, FILE *fp);}\\
    Usually, write one item at a time. having target structure as the 1st arg, sizeof(struct) as the second arg, and 1 as the 3rd arg.
    \item \textbf{int fread(void *ptr, int size, int num, FILE *fp);}\\
    Same thing as fwrite, just reading. Oh right, did you know that when you read long, it's stored in reverse order? Damn like it should totally be on the exam because no one will get it right.
    \item One more tip: If you want to know the offset of the struct you just read, do
    \begin{algorithmic}
        \item ftell(fp) / sizeof(struct example) - 1;
    \end{algorithmic}
\end{itemize}

\section{Struct Wannabes}

\subsection{Bitfields}
You can create fields within struct that do not contain round number of bits.
\begin{algorithmic}
    \item  struct my\_bitfields \{\\
        $\indent$ unsigned int sign: 1;\\
        $\indent$ unsigned int exp: 11;\\
        \};
\end{algorithmic}
Have no clue why this is useful.

\subsection{Union}
Declare just like struct
\begin{algorithmic}
    \item union my\_union \{\\
        $\indent$ int combined\_bytes;\\
        $\indent$ char four\_bytes[4];\\
    \};
\end{algorithmic}
If you don't specify, it assumes that you're initializing the first field. C99 has designated initializer. 
\begin{algorithmic}
    \item union my\_union my\_var = \{ .four\_bytes = \{ a, b, c, d \} \};
\end{algorithmic}

\subsection{Enum}
Attaching a label to a value. You can either assign a value or not. \textbf{Not semicolon, use commas}.
\begin{algorithmic}
    \item enum color \{\\
        $\indent$ TEAL,\\
        $\indent$ TURQUOISE = 4,\\
    \};
    \item enum color my\_fav\_color = TURQUOISE;
    \item enum color my\_2nd\_fav = TEAL;
    \item printf("My fav color is \%d$\backslash$n", TURQUOISE); /* Will print out 4 */
\end{algorithmic}

\subsection{Bitwise Operators}
I know this doesn't belong here but I hate it and didn't want to give it a new section.
\begin{itemize}
    \item \& $\mid$ \^{} $\sim$
    \item Shift operator $\ll$ $\gg$\\
    Every shift left is equivalent to multiplication by two.
    \begin{algorithmic}
        \item y = x $\ll$ 4 /* Equivalent to y = x * $2^4$ */
    \end{algorithmic}
\end{itemize}

\end{document}