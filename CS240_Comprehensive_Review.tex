\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{soul}
\usepackage{bookman}

% https://tex.stackexchange.com/questions/348651/c-code-to-add-in-the-document %
\usepackage{xcolor}
\usepackage{listings}
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    %basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    %keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Bash lstlisting %%%%%
\definecolor{turquoise}{rgb}{0.175,238,238}
\lstdefinestyle{BashStyle}{
    backgroundcolor=\color{turquoise},
    showstringspaces=false,
    commentstyle=\color{red},
    keywordstyle=\color{blue},
    language=bash
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\title{CS240 Comprehensive Review}
\author{Theo Park}
\date{3 May 2022}

\begin{document}

\maketitle

\section{Basics}
\st{C was developed by our lord Turkstra in 1678.}\\
Created by Dennis Ritchie in 1969 (nice) - 1973 at Bell Lab, with a desire to make UNIX portable unlike assembly.
It's portable, fast, and simple, so screw you Javascript.


\section{Compiling and Linking}

\subsection{Gcc Flags}
\begin{itemize}
    \item \textit{-c} Compile file into object file
    \item \textit{-g} Debugging symbols
    \item \textbf{\textit{-Wall}} Include ALL Warning
    \item \textbf{\textit{-Werror}} Turn wanings into errors
    \item \textbf{\textit{-O1, -O2, -O3}} Optimize output code
    \item \textbf{\textit{-o filename}} Output to filename
    \item \textit{-ANSI} Adhere to ANSI std
    \item \textit{-std=C99} Adhere to C99 std
\end{itemize}
Typical homework gcc commands:
\begin{lstlisting}[style=BashStyle]
    $ gcc -Wall -Werror -std=c17 -c hwx.c
    $ gcc -Wall -Werror -std=c16 -c hwx_main.c
    $ gcc -o hwx_main hwx_main.o hwx.c
\end{lstlisting}

\subsection{Linking}
Object file contains binary code, symbol tables, and is a compiled form of a C module.
To make it a complete executable, one must link object files, with one of them containing main().

\section{File I/O}

\subsection{Essentials}
\begin{itemize}
    \item FILE *fopen(char *file\_name, char *mode);\\
    Modes are "r", "w", and "a" (append). Returns file ptr on success, NULL on unsuccess, so one must check the return val of fopen().
    \item int fclose(FILE *file\_pointer);\\
    It does not set the file ptr to NULL, so you have to manually set it to NULL. Return val check isn't necessary in this class.
    \item \textbf{int fprinf(FILE *stream, const char *format, \dots);}
    \item \textbf{int fscanf(FILE *stream, const char *format, \dots);}
    \item int access(char *file\_name, int mode);\\
    Used to check if file can be accessed in "R\_OK", "W\_OK", or "F\_OK" (check for existence) mode.
    \item int feof(FILE *file\_pointer);\\
    Returns non-zero if EOF reached.
    \item int ferror(FILE *file\_pointer);\\
    Returns 0 if error occurs (e.g disk space full).
\end{itemize}

\subsection{Notes with fscanf()}
\begin{itemize}
    \item Utilize \%[] (\%[0-9A-z] \%[\^{}A-z])
    \item \textbf{Field width specifier (e.g \%49s \%49[A-z]). Always one less than the buffer size to account for NUL terminator.}
    \item Assigns variables to pointers; use \& symbol for non-strings.
    \item Returns number of successfully read variables; Check for error using the return value.
\end{itemize}

\subsection{Random Access File I/O}
\begin{itemize}
    \item \textbf{int ftell(FILE *file\_pointer);}\\
    Returns current offset from the beginning of the file (SEEK\_SET) or -1 in case of error.
    \item \textbf{int fseek(FILE *fp, long int offset, int whence);}\\
    Whence values include
    \begin{itemize}
        \item SEEK\_SET: Offset relative to beginning of the file 
        \item SEEK\_CUR: Offset relative to the current position
        \item SEEK\_END: Offset relative to the end of the file
    \end{itemize}
    \item Example of finding how long the file is:
    \begin{lstlisting}[style=CStyle]
        fseek(fp, 0, SEEK_END);
        int len = ftell(fp);
        fseek(fp, 0, SEEK_SET);
    \end{lstlisting}
\end{itemize}

\section{Struct and Typedef}

\subsection{Some Syntax}
\begin{itemize}
    \item Typedef and struct definition:
    \begin{lstlisting}[style=CStyle]
        typedef struct my_data {
            int age;
        } my_data_t;
    \end{lstlisting}
    \item Struct definition and declaration:
    \begin{lstlisting}[style=CStyle]
        struct my_data {
            int age;
        } my_var = { 19 };
    \end{lstlisting}
\end{itemize}

\subsection{Declaration vs Definition}
Declaration is announcing the properties of var (no memory allocation), definition is allocating storages for a var.
\begin{itemize}
    \item Declaration:
    \begin{lstlisting}[style=CStyle]
        struct my_data {
            int age;
        };
    \end{lstlisting}
    \item Definition and initialization:
    \begin{lstlisting}[style=CStyle]
        struct my_data my_var = { 19 };
    \end{lstlisting}
\end{itemize}
Put pure declaration (struct, func prototype, extern) outside of the func, put definition inside func.

\subsection{Initializing/Assigning Elements in Struct}
\begin{lstlisting}[style=CStyle]
    struct my_data {
        int age;
        int random_stuffs[2];
    };
\end{lstlisting}
Initialization is what you expect.
\begin{lstlisting}[style=CStyle]
    struct my_data my_var = { 12, { 3, 4 } };
\end{lstlisting}
Usually, assigning elements are done individually
\begin{lstlisting}[style=CStyle]
    struct my_data my_var = { 122, { 33, 44 } }; /* Oh no mistakes */
    my_var.age = 12;
    my_var.random_stuffs[0] = 3;
    my_var.random_stuffs[1] = 4;
\end{lstlisting}
In C99, you can do it all at once with compound literal.
\begin{lstlisting}[style=CStyle]
    my_var = (struct my_data) { 12, { 3, 4 } };
\end{lstlisting}

\section{Memory}

\subsection{Array and String}
\begin{itemize}
    \item When a global array is initialized, or a local array is partially initialized, any non-initialized elements are 0.
    \item \textbf{Use strncpy(str1, str2, num), with last arg being sizeof(str1)} (in stack allocated memory settings).
    \item strcmp(str1, str2) returns 0 if they are the same, positive number if str2 comes before str1, negative if str1 comes before str2.
\end{itemize}

\subsection{Memory Map}
Cry.

\subsection{Padding}
Structure is padded in C when smaller size variable is followed by bigger size variable. 
Padding of sizeof(bigger\_var) - sizeof(smaller\_var) will be added in between for a faster access.
\begin{lstlisting}[style=CStyle]
    struct example {
        char a; /* 1 bytes */
        char b; /* 1 bytes */
        int c; /* 4 bytes */
        /* Prev. element adding up to 6, thus 2 bytes of padding */
        struct example *next; /* 8 bytes */
    };
\end{lstlisting}
Size of struct example is 16 bytes (in 64 bit system). Remember that the size of structure should be a multiple of the biggest variable.

\subsection{Binary File I/O}
\begin{itemize}
    \item \textbf{int fwrite(void *ptr, int size, int num, FILE *fp);}\\
    Usually, write one item at a time. having target structure as the 1st arg, sizeof(struct) as the second arg, and 1 as the 3rd arg.
    \item \textbf{int fread(void *ptr, int size, int num, FILE *fp);}\\
    Same thing as fwrite, just reading. Oh right, did you know that when you read long, it's stored in reverse order? Damn like it should totally be on the exam because no one will get it right.
    \item One more tip: If you want to know the offset of the struct you just read, do
    \begin{lstlisting}[style=CStyle]
        ftell(fp) / sizeof(struct example) - 1;
    \end{lstlisting}
\end{itemize}

\section{Struct Wannabes}

\subsection{Bitfields}
You can create fields within struct that do not contain round number of bits.
\begin{lstlisting}[style=CStyle]
    struct my_bitfields {
        unsigned int sign: 1;
        unsigned int exp: 11;
    };
\end{lstlisting}
Have no clue why this is useful.

\subsection{Union}
Declare just like struct
\begin{lstlisting}[style=CStyle]
    union my_union {
        int combined_bytes;
        char four_bytes[4];
    };
\end{lstlisting}
If you don't specify, it assumes that you're initializing the first field. C99 has designated initializer. 
\begin{lstlisting}[style=CStyle]
    union my_union my_var = { .four_bytes = { a, b, c, d} };
\end{lstlisting}

\subsection{Enum}
Attaching a label to a value. You can either assign a value or not. \textbf{Not semicolon, use commas}.
\begin{lstlisting}[style=CStyle]
    enum color {
        TEAL,
        TURQUOISE = 4,
    };
    enum color my_fav_color = TURQUOISE;
    enum color my_2nd_fav = TEAL;
    printf("My fav color is \%d\n", TURQUOISE); /* Will print out 4 */
\end{lstlisting}

\subsection{Bitwise Operators}
I know this doesn't belong here but I hate it and didn't want to give it a new section.
\begin{itemize}
    \item \& $\mid$ \^{} $\sim$
    \item Shift operator $\ll$ $\gg$\\
    Every shift left is equivalent to multiplication by two.
    \begin{lstlisting}[style=CStyle]
        y = x << 4 /* Equivalent to y = x * 2^4 */
    \end{lstlisting}
\end{itemize}

\section{Pointer Pointer Pointer!}
\& Operator is used to determine the address of an element. * operator is used to manipulate the contents at the address of a variable.

\subsection{Array and Pointer (They are the samething)}
\begin{itemize}
    \item Arrays are equivalent to pointer (not the other way around), and ptr can be used as arrays.
    \item Differences are
    \begin{itemize}
        \item \textbf{You cannot assign something new to array unlike ptr.}
        \begin{lstlisting}[style=CStyle]
            ptr = arr; /* allowed */
            arr = ptr; /* NOT allowed */
        \end{lstlisting}
        \item \textbf{Array definition allocates memory for every elements in the array}, whereas you need to dynamically allocate memory for a var that ptr points to (ptr itself is allocated; 8 bytes).
    \end{itemize}
\end{itemize}

\subsection{Pointer Arithmetic}
You can move around the array using arithmetic on ptr.
\begin{lstlisting}[style=CStyle]
    int arr[10] = { 1, 2, 3, 4, 5 };
    int *ptr = arr; /* Points to the 1st element in the arr - 1 */
    ptr = &arr[1]; /* Now points to the 2nd element in the arr - 2 */
    ptr++; /* Points to the 3rd element - 3 */
    ptr += 3; /* Points to 6th element - 0 - Remember uninitialized elements are 0 */
\end{lstlisting}

\section{GDB}
\begin{lstlisting}[style=BashStyle]
    $ gcc -g debugging.c -o debugging # Don't forget -g flag
    $ gdb debugging
    (gdb) run
    (gdb) bt # Backtrace the crash point
    (gdb) quit
\end{lstlisting}

\section{Linked List and Dynamic Memory Allocation}

\subsection{$\rightarrow$ Operator}
\begin{lstlisting}[style=CStyle]
    struct my_data my_var = { 19 };
    struct my_data *my_ptr = &my_var;
    printf("%d\n", (*my_ptr).age); /* Will print 19 */
    printf("%d\n", my_ptr->age); /* Will also print 19! */
\end{lstlisting}
Be aware that (*ptr)-\textgreater age and *ptr-\textgreater age (Which is the same as *(ptr-\textgreater age)) are different.

\subsection{malloc() and free()}

\end{document}